# Pods

- [Pods concept](https://github.com/Ariel-Yu/knowledge-bases/blob/master/kubernetes/3.1-pods.md#pods-concept)
- [Pods kubectl](https://github.com/Ariel-Yu/knowledge-bases/blob/master/kubernetes/3.1-pods.md#pods-kubectl)
- [Pods yaml](https://github.com/Ariel-Yu/knowledge-bases/blob/master/kubernetes/3.1-pods.md#pods-yml)

## Pods concept

* Pod usually has a **1:1** relationship with container
* To scale up the application, we can add more pods with the **same** application image to the same node or add more nodes with containers with the **same** application image to the same cluster
* A pod can have multiple containers. These containers usually have **different** application images. Some of the containers are usually helper containers of another container
* What resources can be shared within a pod
  * Network namespace
  * Storage
  * Same thread
* Pod is transient, when a pod is down, pod managers (replicasets, deployments, daemonsets, statefulsets, jobs) are the ones responsible to bring up a new pod

## Pods kubectl

```
kubectl run <pod_name> --image=<image_name> --restart=Never
kubectl create -f <pod_definition_file>
kubectl create deployment <deployment_name> --image=<image_name> â†’ Create a deployment with a replicaset and a pod

<SHORTNAME of pods = po>
kubectl get pods [<pod_name>]
kubectl get pods [<pod_name>] -o wide
kubectl describe pods [<pod_name>]
kubectl explain pods[.spec.containers.image] --recursive [| wc] [| less]
kubectl logs <pod_name> [<container_name>]

kubectl delete pods <pod_name>
kubectl detele pods -l <label_name>: <label_value>

kubectl exec [-c <container_name>] -it <pod_name> -- /bin/bash -> Get into the container and run bash commands
```

## Pods yml

pod-definition.yml

- nginx
  - The container is listening to port 80
```
apiVersion: v1

kind: Pod

metadata:
  name: ariel-pod
  labels:
    app: ariel

spec:
  containers:
    - name: nginx-container
      image: nginx
      ports:
        containerPort: 80
```

- postgres
```
apiVersion: v1
kind: Pod
metadata:
  name: postgres
  labels:
    tier: db-tier

- spec:
  containers:
    - name: postgres
      image: postgres
      env:
        - name: POSTGRES_PASSWORD
          value: mysecretpassword
```

Create a pod with a yaml file
```
kubectl create -f pod-definition.yml
```

## Pods features

### volumeMounts
```
apiVersion: v1

kind: Pod

metadata:
  name: ariel-pod
  labels:
    app: ariel

spec:
  containers:
    - name: nginx-container
      image: nginx
      ports:
        containerPort: 80
      volumeMounts:
        - name: workdir
          mountPath: /usr/share/nginx/html
```
- The container has a shared volume at **its** path /usr/share/nginx/html 
  - `kubectl exec -it <pod_name> [-c <container_name>] -- sh
  - cd /usr/share/nginx/html`
  
### securityContext

### Probes
Health checkes of the `containers`. Probes are defined on the container level

- There are three methods can be used by the probes:
  - Commands
  - HTTP request
  - TCP socket
- initialDelaySeconds: How long kubelete will wait before it executes the probe
- periodSeconds: How often kubelete will run the probe

#### readinessProbe
Check if a container is ready. kubelete will only send traffic to the containers whose readinessProbe is passed
 
```
apiVersion: v1

kind: Pod

metadata:
  name: ariel-pod
  labels:
    app: ariel

spec:
  containers:
    - name: nginx-container
      image: nginx
      ports:
        containerPort: 80
      volumeMounts:
        - name: workdir
          mountPath: /usr/share/nginx/html
      readinessProbe:
        exec:
          command:
            - cat
            - /tmp/healthy
        initialDelaySeconds: 5
        periodSeconds: 5
```
- The readiness probe is passed after `cat /tmp/healthy` command is executed

 #### livenessPorbe
